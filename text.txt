Работа с консолью. Ввод пользователя
Console.Write(
    "Вы ввели {0}", // {0} - placeholder - место для подстановки параметра 
    str0,           // 0 - индекс того, что идет после запятой - отсчет с 0
    str1            
)

string str = Console.ReadLine(); // считывает строку до Enter включая все символы (пробелы и т.п.).
                                    срабатывает по нажатию Enter

int c = Console.Read(); // считывает один символ. Срабатывает по нажатию Enter. Возвращает int значение, результат 
                            которого является переведенный символ в Юникод и возвращает номер в таблице
Если буфер консоли не пустой, то не останавливает программу и не ждет ввода пользователя.
Сам символ Enter встроку не попадает. Символы \n и \r также считываются

ConsoleKeyInfo k = Console.ReadKey(); // Считывает один символ и сразу продолжает программу.

 ConsoleKeyInfo k = Console.ReadKey(true); // введенный символ не отображается  

 Неизменяемые (immutable) строки - не дают возможность изменения своего состава: str[1] = 'X' - не разрешено


Операции сложения строк, в том числе +=, создают новые строки.
str += c - new(str+c)=>str, старое значение str уходит в мусор

Например: считываем файл посимвольно и собираем в строку. 
Пусть в файле 100 символов
str "" -> "1" -> "12" -> "123" -> ... -> "123...100"
все объекты (str), кроме последнего, станут "мусором"
? каков их объем? 1+2+3...+99
Строки из 100 символов потрачено 5к памяти
? 1000 символов? -> 500к памяти
Решение этой проблемы: использование StringBuilder - "накопитель" фрагментов с последующим соединением
